<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>赛车小游戏</title>
  <!-- 通过 CDN 引入 Phaser，无需安装 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin:0; background:#222; display:flex; height:100vh; align-items:center; justify-content:center; }
    #game-container { box-shadow:0 10px 30px rgba(0,0,0,.35); }
  </style>
</head>
<body>
  <div id="game-container"></div>
<script>
const W = 400, H = 600;

const config = {
  type: Phaser.AUTO,
  parent: "game-container",
  width: W,
  height: H,
  backgroundColor: "#f5f5f5",
  physics: { default: "arcade", arcade: { debug: false } },
  scene: { preload, create, update }
};

let car, cursors, score=0, scoreText;
let obstacles;
let laneLines = [];
let speed = 240;           // 障碍物/道路滚动速度
let spawnTimer = 0;        // 生成障碍物计时
let spawnInterval = 800;   // 生成间隔（毫秒）

new Phaser.Game(config);

function preload() {}

/** 画赛道的中线（滚动效果） */
function createLaneLines(scene) {
  const gap = 40;  // 线段之间的空隙
  for (let y = -H; y < H; y += 80) {
    const line = scene.add.rectangle(W/2, y, 8, 40, 0xcccccc);
    scene.physics.add.existing(line, true);
    laneLines.push(line);
  }
}

function create() {
  // 赛道两侧（视觉边界）
  this.add.rectangle(50, H/2, 6, H, 0x444444);
  this.add.rectangle(W-50, H/2, 6, H, 0x444444);

  // 中线
  createLaneLines(this);

  // 玩家赛车
  car = this.add.rectangle(W/2, H-100, 50, 90, 0xe53935);
  this.physics.add.existing(car);
  car.body.setCollideWorldBounds(true);

  // 障碍物组
  obstacles = this.physics.add.group();

  // 碰撞检测：撞到就结束
  this.physics.add.overlap(car, obstacles, () => gameOver(this), null, this);

  // 键盘
  cursors = this.input.keyboard.createCursorKeys();

  // 触摸/鼠标（移动端也能玩）
  this.input.on('pointermove', (p) => {
    car.x = Phaser.Math.Clamp(p.x, 50+25, W-50-25);
  });

  // 分数
  scoreText = this.add.text(12, 12, "得分：0", { fontSize: "20px", color: "#111" });
}

/** 生成障碍物（随机车道） */
function spawnObstacle(scene) {
  const lanes = [W*0.3, W*0.5, W*0.7]; // 三条虚拟车道中心
  const x = lanes[Phaser.Math.Between(0, lanes.length - 1)];
  const rect = scene.add.rectangle(x, -60, 50, 90, 0x1565c0);
  obstacles.add(rect);
  rect.body.setVelocityY(speed);
}

/** 游戏结束 */
function gameOver(scene) {
  scene.physics.pause();
  scene.add.rectangle(W/2, H/2, W*0.8, 160, 0x000000, 0.7);
  scene.add.text(W/2, H/2 - 20, "游戏结束", { fontSize: "36px", color: "#fff" }).setOrigin(0.5);
  scene.add.text(W/2, H/2 + 24, "刷新页面重新开始", { fontSize: "18px", color: "#fff" }).setOrigin(0.5);
}

function update(time, delta) {
  // 车辆左右移动（键盘）
  const vx = (cursors.left.isDown ? -280 : cursors.right.isDown ? 280 : 0);
  car.body.setVelocityX(vx);

  // 赛道白线滚动
  laneLines.forEach(line => {
    line.y += speed * (delta / 1000);
    if (line.y > H + 40) line.y = -40;
  });

  // 生成障碍物
  spawnTimer += delta;
  if (spawnTimer > spawnInterval) {
    spawnTimer = 0;
    spawnObstacle(this);
    // 难度随分数增加
    if (spawnInterval > 450) spawnInterval -= 10;
    speed = Math.min(speed + 2, 460);
  }

  // 回收越界障碍物并加分
  obstacles.children.iterate(obj => {
    if (!obj) return;
    if (obj.y > H + 100) { obj.destroy(); score += 1; scoreText.setText("得分：" + score); }
  });
}
</script>
</body>
</html>
